//-----------------------------------------------------------------------------
// File: GlobalMemoryMapHeaderWriter.cpp
//-----------------------------------------------------------------------------
// Project: Kactus 2
// Author: Mikko Teuho
// Date: 08.05.2015
//
// Description:
// The implementation for creating c-headers of global memory maps.
//-----------------------------------------------------------------------------

#include "GlobalMemoryMapHeaderWriter.h"

#include <library/LibraryManager/libraryinterface.h>

#include <Plugins/PluginSystem/IPluginUtility.h>
#include <Plugins/MemoryMapHeaderGenerator/fileSaveDialog/filesavedialog.h>

#include <editors/ComponentEditor/common/ListParameterFinder.h>

#include <common/utils.h>

#include <IPXACTmodels/businterface.h>
#include <IPXACTmodels/masterinterface.h>
#include <IPXACTmodels/mirroredslaveinterface.h>
#include <IPXACTmodels/slaveinterface.h>

#include <QDate>
#include <QDir>
#include <QDesktopServices>

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::GlobalMemoryMapHeaderWriter()
//-----------------------------------------------------------------------------
GlobalMemoryMapHeaderWriter::GlobalMemoryMapHeaderWriter(IPluginUtility* utility,
    QSharedPointer<Design> componentDesign, QSharedPointer<DesignConfiguration> componentDesignConfig,
    QObject* parentObject):
BaseMemoryMapHeaderWriter(utility),
parentObject_(parentObject),
componentDesign_(componentDesign),
componentDesignConfig_(componentDesignConfig),
operatedInterfaces_(),
saveOptions_()
{

}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::GlobalMemoryMapHeaderWriter()
//-----------------------------------------------------------------------------
GlobalMemoryMapHeaderWriter::~GlobalMemoryMapHeaderWriter()
{

}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::writeMemoryMapHeader()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::writeMemoryMapHeader(QSharedPointer<Component> globalComponent,
    QList<GlobalHeaderSaveModel::SaveFileOptions*> saveOptions)
{
    saveOptions_ = saveOptions;
    QList<GlobalHeaderSaveModel::SaveFileOptions*> options = saveOptions_;

    bool changed = false;

	operatedInterfaces_.clear();
    
    GlobalHeaderSaveModel model(utility_->getLibraryInterface(), parentObject_);
    model.setDesign(globalComponent, componentDesign_);

    if (options.isEmpty())
    {
        // create the dialog to display the headers to be generated
        FileSaveDialog dialog(utility_->getParentWidget());
        dialog.setModel(&model);

        int result = dialog.exec();

        // if user clicked cancel
        if (result == QDialog::Rejected)
        {
            informGenerationAbort();
            return;
        }

        options = model.getHeaderOptions();
    }

    informStartOfGeneration();

	foreach (GlobalHeaderSaveModel::SaveFileOptions* headerOpt, options)
    {
		QFile file(headerOpt->fileInfo_.absoluteFilePath());

        checkDirectoryStructure(headerOpt->fileInfo_.dir());

		if (!file.open(QFile::Truncate | QFile::WriteOnly))
        {
            openFileErrorMessage(headerOpt->fileInfo_.absoluteFilePath());
			break;
		}

		QTextStream stream(&file);

        QString description (" * Header file generated by Kactus2 for instance \"" + headerOpt->instance_ +
            "\" interface \"" + headerOpt->interface_ + "\".\n"+
            " * This file contains addresses of the memories and registers defined in the memory maps " +
            "of connected components.\n" +
            " * Source component: " + headerOpt->comp_.toString() + ".\n" +
        	"*/\n");

        QString headerGuard ("__" + headerOpt->instance_.toUpper() + "_" + headerOpt->interface_.toUpper() + "_H");

        writeTopOfHeaderFile(stream, headerOpt->fileInfo_.fileName(), headerGuard, description);

		Interface cpuMasterInterface(headerOpt->instance_, headerOpt->interface_);
		operatedInterfaces_.append(cpuMasterInterface);

		// start the address parsing from the cpu's interface
		parseInterface(0, stream, cpuMasterInterface);

		stream << "#endif /* " << headerGuard << " */" << endl << endl;

        file.close();

        informWritingFinished(headerOpt->fileInfo_.fileName());

		addHeaderFile(globalComponent, headerOpt->fileInfo_, headerOpt->instance_, QStringList(),
            headerOpt->instanceId_);

		// a header file was added
		changed = true;

		// the list must be cleared when moving to completely new master interface so each header generation
        // starts from scratch.
		operatedInterfaces_.clear();
	}

	if (changed)
    {
		// save the changes to the file sets
		utility_->getLibraryInterface()->writeModelToFile(globalComponent);
	}

	// clear the members for next generation run
    componentDesign_.clear();
	operatedInterfaces_.clear();


    informGenerationComplete();
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseInterface()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseInterface(qint64 offset, QTextStream& stream, const Interface& interface)
{
    Q_ASSERT(componentDesign_);
    Q_ASSERT(componentDesign_->containsHWInstance(interface.getComponentRef()));

	// parse the component containing the interface
	VLNV compVLNV = componentDesign_->getHWComponentVLNV(interface.getComponentRef());
	QSharedPointer<LibraryComponent> libComp = utility_->getLibraryInterface()->getModel(compVLNV);
	QSharedPointer<Component> component = libComp.dynamicCast<Component>();
	Q_ASSERT(component);

    if (component->getInterfaceMode(interface.getBusRef()) == General::MASTER)
    {
        parseMasterInterface(offset, component, stream, interface);
    }
    else if (component->getInterfaceMode(interface.getBusRef()) == General::SLAVE)
    {
        parseSlaveInterface(offset, component, stream, interface);
    }
    else if (component->getInterfaceMode(interface.getBusRef()) == General::MIRROREDSLAVE)
    {
        parseMirroredSlaveInterface(offset, component, stream, interface);
    }
    else if (component->getInterfaceMode(interface.getBusRef()) == General::MIRROREDMASTER)
    {
        parseMirroredMasterInterface(offset, component, stream, interface);
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseMasterInterface()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseMasterInterface(qint64 offset, QSharedPointer<Component> component,
    QTextStream& stream, const Interface& interFace)
{
    QString instanceID = getInstanceID(interFace.getComponentRef());
    QSharedPointer<ListParameterFinder> finder = createParameterFinder(instanceID, component);

    QString masterBaseAddress = component->getBusInterface(interFace.getBusRef())->getMaster()->getBaseAddress();

    offset += Utils::str2Int(parsedValueFor(masterBaseAddress, finder));

    QList<Interface> connected = componentDesign_->getConnectedInterfaces(interFace);
    foreach (Interface targetInterface, connected)
    {
        if (operatedInterfaces_.contains(targetInterface))
        {
            continue;
        }
        operatedInterfaces_.append(targetInterface);
        parseInterface(offset, stream, targetInterface);
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseSlaveInterface()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseSlaveInterface(qint64 offset, QSharedPointer<Component> component,
    QTextStream& stream, const Interface& interFace)
{
    QSharedPointer<SlaveInterface> slave = component->getBusInterface(interFace.getBusRef())->getSlave();
    Q_ASSERT(slave);

    if (!slave->getBridges().isEmpty())
    {
        foreach (QSharedPointer<SlaveInterface::Bridge> bridge, slave->getBridges())
        {
            if (bridge->opaque_)
            {
                utility_->printError(QObject::tr("An opaque bridge was found in interface ") +
                    interFace.getBusRef() + QObject::tr(" in instance ") + interFace.getComponentRef() +
                    QObject::tr(". Currently, opaque bridges are handled as transparent bridges."));
            }
        }
    }

    QSharedPointer<MemoryMap> memMap = component->getMemoryMap(slave->getMemoryMapRef());
    if (memMap && memMap->containsSubItems())
    {
        stream << "/*" << endl;
        stream << " * Instance: " << interFace.getComponentRef() << " Interface: " << interFace.getBusRef() << endl;
        stream << " * Instance base address: 0x" << QString::number(offset, 16) << endl;
        stream << " * Source component: " << component->getVlnv()->toString() << endl;

        // if there is a description for the component instance
        QString instanceDesc = componentDesign_->getHWInstanceDescription(interFace.getComponentRef());
        if (!instanceDesc.isEmpty())
        {
            stream << " * Description:" << endl;
            stream << " * " << instanceDesc << endl;
        }

        QString instanceID = getInstanceID(interFace.getComponentRef());

        QSharedPointer<ListParameterFinder> finder = createParameterFinder(instanceID, component);

        stream << " * The defines for the memory map \"" << memMap->getName() << "\":" << endl;
        stream << "*/" << endl << endl;

        writeMemoryAddresses(finder, memMap, stream, offset, interFace.getComponentRef());

        // if the registers within the instance are unique then do not concatenate with address block name
        QStringList regNames;
        if (memMap->uniqueRegisterNames(regNames))
        {
            writeRegisterFromMemoryMap(finder, memMap, stream, false, offset, interFace.getComponentRef());
        }
        else
        {
            writeRegisterFromMemoryMap(finder, memMap, stream, true, offset, interFace.getComponentRef());
        }
    }

    if (slave->hasBridge())
    {
        QStringList masterNames = slave->getMasterReferences();
        foreach (QString masterRef, masterNames)
        {
            if (!component->hasInterface(masterRef))
            {
                continue;
            }

            Interface masterIF(interFace.getComponentRef(), masterRef);
            if (operatedInterfaces_.contains(masterIF))
            {
                continue;
            }

            operatedInterfaces_.append(masterIF);
            parseInterface(offset, stream, masterIF);
        }
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseMirroredSlaveInterface()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseMirroredSlaveInterface(qint64 offset, QSharedPointer<Component> component,
    QTextStream& stream, const Interface& interFace)
{
    // increase the offset by the remap address of the mirrored slave interface
    QString remapStr = component->getBusInterface(interFace.getBusRef())->getMirroredSlave()->getRemapAddress();

    QString instanceId = getInstanceID(interFace.getComponentRef());
    QSharedPointer<ListParameterFinder> finder = createParameterFinder(instanceId, component);

    QString remapValue = parsedValueFor(remapStr, finder);
    offset += remapValue.toInt();

    QList<Interface> connected = componentDesign_->getConnectedInterfaces(interFace);
    foreach (Interface targetInterface, connected)
    {
        if (operatedInterfaces_.contains(targetInterface))
        {
            continue;
        }

        operatedInterfaces_.append(targetInterface);
        parseInterface(offset, stream, targetInterface);
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::parseMirroredMaster()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::parseMirroredMasterInterface(qint64 offset, QSharedPointer<Component> component,
    QTextStream& stream, const Interface& interFace)
{
    // mirrored master interfaces are connected via channels
    // find the interfaces connected to the specified mirrored master interface
    QList<QSharedPointer<const BusInterface> > connectedInterfaces =
        component->getChannelConnectedInterfaces(interFace.getBusRef());

    foreach (QSharedPointer<const BusInterface> busif, connectedInterfaces)
    {
        Interface connectedInterface(interFace.getComponentRef(), busif->getName());
        if (operatedInterfaces_.contains(connectedInterface))
        {
            continue;
        }
        operatedInterfaces_.append(connectedInterface);
        parseInterface(offset, stream, connectedInterface);
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::displayMemoryMapHeader()
//-----------------------------------------------------------------------------
void GlobalMemoryMapHeaderWriter::displayMemoryMapHeader(QString const& filePath) const
{
    if (saveOptions_.isEmpty())
    {
        QDesktopServices::openUrl(QUrl::fromLocalFile(filePath));
    }
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::checkConfigurableElementValues()
//-----------------------------------------------------------------------------
QSharedPointer<ListParameterFinder> GlobalMemoryMapHeaderWriter::createParameterFinder(QString const& instanceID,
    QSharedPointer<Component> component)
{
    QSharedPointer<QList<QSharedPointer<Parameter> > > configurableElementValues
        (new QList<QSharedPointer<Parameter> > ());

    QMap<QString, QString> configurableElementsInInstance;

    if (componentDesignConfig_)
    {
        configurableElementsInInstance = componentDesignConfig_->getConfigurableElementValues(instanceID);
    }

    foreach (QSharedPointer<Parameter> parameterPointer, *component->getParameters())
    {
        QSharedPointer<Parameter> newConfigurableElement (new Parameter(*(parameterPointer)));

        if (configurableElementsInInstance.contains(newConfigurableElement->getValueId()))
        {
            newConfigurableElement->setValue(configurableElementsInInstance.value(
                newConfigurableElement->getValueId()));
        }

        configurableElementValues->append(newConfigurableElement);
    }

    QSharedPointer<ListParameterFinder> listFinder (new ListParameterFinder());
    listFinder->setParameterList(configurableElementValues);

    return listFinder;
}

//-----------------------------------------------------------------------------
// Function: GlobalMemoryMapHeaderWriter::getInstanceID()
//-----------------------------------------------------------------------------
QString GlobalMemoryMapHeaderWriter::getInstanceID(QString const& interfaceReference) const
{
    foreach (ComponentInstance instance, componentDesign_->getComponentInstances())
    {
        if (instance.getInstanceName() == interfaceReference)
        {
            return instance.getUuid();
        }
    }

    // This should not be reached.
    return QString();
}
