/* 
 *	Created on: 15.2.2013
 *	Author:		Antti Kamppi
 * 	File name:	memorymapheadergenerator.cpp
 * 	Project:	Kactus 2
*/

#include "memorymapheadergenerator.h"
#include <LibraryManager/libraryinterface.h>
#include <PluginSystem/IPluginUtility.h>
#include <common/dialogs/fileSaveDialog/filesavedialog.h>
#include "localheadersavemodel.h"
#include "globalheadersavemodel.h"
#include <models/memorymap.h>
#include <models/generaldeclarations.h>
#include <models/fileset.h>
#include <models/file.h>
#include <models/design.h>
#include <models/businterface.h>
#include <models/masterinterface.h>
#include <common/KactusAttribute.h>
#include <common/utils.h>

#include <QtPlugin>
#include <QFileInfo>
#include <QFile>
#include <QTextStream>
#include <QMessageBox>
#include <QCoreApplication>
#include <QDate>
#include <QSettings>
#include <QDir>
#include <QString>

#include <QDebug>

const QString MemoryMapHeaderGenerator::DEFAULT_TARGET_FILESET = QString("cSources");

MemoryMapHeaderGenerator::MemoryMapHeaderGenerator():
utility_(NULL) {
}

MemoryMapHeaderGenerator::~MemoryMapHeaderGenerator() {
}

QString const& MemoryMapHeaderGenerator::getName() const {
	static QString name(tr("Memory Map Header Generator"));
	return name;
}

QString const& MemoryMapHeaderGenerator::getVersion() const {
	static QString version(tr("1.0"));
	return version;
}

QString const& MemoryMapHeaderGenerator::getDescription() const {
	static QString description(tr("Generates C-headers for memory maps of a component"));
	return description;
}

//-----------------------------------------------------------------------------
// Function: MemoryMapHeaderGenerator::getSettingsWidget()
//-----------------------------------------------------------------------------
PluginSettingsWidget* MemoryMapHeaderGenerator::getSettingsWidget()
{
    return new PluginSettingsWidget();
}


//-----------------------------------------------------------------------------
// Function: MemoryMapHeaderGenerator::getIcon()
//-----------------------------------------------------------------------------
QIcon MemoryMapHeaderGenerator::getIcon() const
{
    return QIcon(":icons/headerGenerator24.png");
}

bool MemoryMapHeaderGenerator::checkGeneratorSupport( QSharedPointer<LibraryComponent const> libComp,
	QSharedPointer<LibraryComponent const> libDes) const {
	
	// make sure the object is a component
	QSharedPointer<Component const> comp = libComp.dynamicCast<Component const>();
	if (!comp) {
		return false;
	}

	// if there is no design then header is generated for local memory maps
	if (!libDes) {
		return comp->hasLocalMemoryMaps();
	}

	// make sure the second parameter is for a design object
	QSharedPointer<Design const> design = libDes.dynamicCast<Design const>();
	// the design must be a HW design
	if (design) {
		return comp->getComponentImplementation() == KactusAttribute::KTS_HW;
	}
	else {
		return false;
	}
}

void MemoryMapHeaderGenerator::runGenerator( IPluginUtility* utility,
	QSharedPointer<LibraryComponent> libComp,
	 QSharedPointer<LibraryComponent> libDes) {

	utility_ = utility;

	QSharedPointer<Component> comp = libComp.dynamicCast<Component>();
	Q_ASSERT(comp);

	// if there is no design object then create headers for local memory maps
	if (!libDes) {
		generateLocalMemMapHeaders(comp);
	}

	// if there is a design then headers are generated for the CPU instances
	else {
		QSharedPointer<Design> design = libDes.dynamicCast<Design>();
		Q_ASSERT(design);

		generateGlobalHeaders(comp, design);
	}
}

void MemoryMapHeaderGenerator::addHeaderFile( QSharedPointer<Component> component, const QFileInfo& fileInfo ) const {
	QString xmlDir = utility_->getLibraryInterface()->getDirectoryPath(*component->getVlnv());
	
	// if the directory does not exist
	QDir ipXactDir(xmlDir);
	Q_ASSERT(ipXactDir.exists());
	Q_ASSERT(fileInfo.exists());

	// calculate the relative path 
	QString relPath =  ipXactDir.relativeFilePath(fileInfo.absoluteFilePath());

	// file set where the file is added to
	QSharedPointer<FileSet> fileSet = component->getFileSet(LocalHeaderSaveModel::DEFAULT_HEADER_DIR);
	Q_ASSERT(fileSet);

	// the file
	QSharedPointer<File> file = fileSet->addFile(relPath);
	Q_ASSERT(file);

	file->clearFileTypes();
	file->addFileType("cSource");
	file->addFileType("cppSource");
	file->setDescription(tr("A header file generated by Kactus2.\n"
		"This file contains the register and memory addresses defined in the memory map(s)"));
}

void MemoryMapHeaderGenerator::generateLocalMemMapHeaders( QSharedPointer<Component> comp ) {
	// the model which displays the local memory maps and their header paths
	LocalHeaderSaveModel model(utility_->getLibraryInterface(), this);
	model.setComponent(comp);

	FileSaveDialog dialog(utility_->getParentWidget());
	dialog.setModel(&model);

	int result = dialog.exec();

	// if user clicked cancel
	if (result == QDialog::Rejected) {
		return;
	}

	// if there are no files to add then there is no need to save the component
	bool changed = false;

	// get list of the selected paths and generate each header
	const QList<LocalHeaderSaveModel::SaveFileOptions*>& options = model.getHeaderOptions();
	foreach (LocalHeaderSaveModel::SaveFileOptions* headerOpt, options) {

		QFile file(headerOpt->fileInfo_.absoluteFilePath());

		// make sure the directory structure exists for the file
		QDir dir(headerOpt->fileInfo_.dir());
		QString dirName(dir.dirName());
		dir.cdUp();
		dir.mkpath(dirName);

		// open the file and erase all old contents if any exists

		// if file could not be opened
		if (!file.open(QFile::Truncate | QFile::WriteOnly)) {

			QString message(tr("File: %1 could not be opened for writing.").arg(headerOpt->fileInfo_.absoluteFilePath()));
			QMessageBox::critical(utility_->getParentWidget(), QCoreApplication::applicationName(), message);
			break;
		}
		// now file has been opened for writing

		// open file stream to write to
		QTextStream stream(&file);

		// write header comments of the file
		stream << "/*" << endl;
		stream << " * File: " << headerOpt->fileInfo_.fileName() << endl;
		stream << " * Created on: " << QDate::currentDate().toString("dd.MM.yyyy") << endl;

		QSettings settings;
		QString userName = settings.value("General/Username", getenv("USERNAME")).toString();

		stream << " * Generated by: " << userName << endl;
		stream << " *" << endl;
		stream << " * Description:" << endl;
		stream << " * Header file generated by Kactus2 from local memory map \"" << headerOpt->localMemMap_->getName() << "\"." << endl;
		stream << " * This file contains addresses of the memories and registers defined in the local memory map." << endl;
		stream << " * Source component: " << comp->getVlnv()->toString() << "." << endl;
		stream << "*/" << endl;
		stream << endl;

		// write the memory addresses
		headerOpt->localMemMap_->writeMemoryAddresses(stream, 0);

		// if the register names are unique then there is no need to add address block name
		QStringList regNames;
		if (headerOpt->localMemMap_->uniqueRegisterNames(regNames)) {
			headerOpt->localMemMap_->writeRegisters(stream, 0, false);
		}
		// if there are registers with same names then address block names must be
		// included in the defines
		else {
			headerOpt->localMemMap_->writeRegisters(stream, 0, true);
		}

		// close the file after writing
		file.close();

		// add the file to the component's file sets
		addHeaderFile(comp, headerOpt->fileInfo_);

		// a header file was added
		changed = true;
	}

	if (changed) {
		// save the changes to the file sets
		utility_->getLibraryInterface()->writeModelToFile(comp);
	}
}

void MemoryMapHeaderGenerator::generateGlobalHeaders( QSharedPointer<Component> comp, QSharedPointer<Design> design ) {
	
	// the model which manages the dialog contents
	GlobalHeaderSaveModel model(utility_->getLibraryInterface(), this);
	model.setDesign(comp, design);

	// create the dialog to display the headers to be generated
	FileSaveDialog dialog(utility_->getParentWidget());
	dialog.setModel(&model);

	int result = dialog.exec();

	// if user clicked cancel
	if (result == QDialog::Rejected) {
		return;
	}

	// if there are no files to add then there is no need to save the component
	bool changed = false;

	const QList<GlobalHeaderSaveModel::SaveFileOptions*>& options = model.getHeaderOptions();
	foreach (GlobalHeaderSaveModel::SaveFileOptions* headerOpt, options) {
		QFile file(headerOpt->fileInfo_.absoluteFilePath());

		// make sure the directory structure exists for the file
		QDir dir(headerOpt->fileInfo_.dir());
		if (!dir.exists()) {
			QString dirName(dir.dirName());
			dir.cdUp();
			dir.mkpath(dirName);
		}

		// open the file and erase all old contents if any exists

		// if file could not be opened
		if (!file.open(QFile::Truncate | QFile::WriteOnly)) {

			QString message(tr("File: %1 could not be opened for writing.").arg(headerOpt->fileInfo_.absoluteFilePath()));
			QMessageBox::critical(utility_->getParentWidget(), QCoreApplication::applicationName(), message);
			break;
		}
		// now file has been opened for writing

		// open file stream to write to
		QTextStream stream(&file);

		// write header comments of the file
		stream << "/*" << endl;
		stream << " * File: " << headerOpt->fileInfo_.fileName() << endl;
		stream << " * Created on: " << QDate::currentDate().toString("dd.MM.yyyy") << endl;

		QSettings settings;
		QString userName = settings.value("General/Username", getenv("USERNAME")).toString();

		stream << " * Generated by: " << userName << endl;
		stream << " *" << endl;
		stream << " * Description:" << endl;
		stream << " * Header file generated by Kactus2 for instance \"" << headerOpt->instance_ << 
			"\" interface \"" << headerOpt->interface_ << "\"." << endl;
		stream << " * This file contains addresses of the memories and registers defined in the memory maps of connected components." << endl;
		stream << " * Source component: " << headerOpt->comp_.toString() << "." << endl;
		stream << "*/" << endl;
		stream << endl;

		// parse the cpu instance
		QSharedPointer<const LibraryComponent> libComp = utility_->getLibraryInterface()->getModelReadOnly(headerOpt->comp_);
		QSharedPointer<const Component> cpuComp = libComp.dynamicCast<const Component>();
		Q_ASSERT(cpuComp);
		QString masterBaseStr = cpuComp->getBusInterface(headerOpt->interface_)->getMaster()->getBaseAddress();
		qint64 masterBase = Utils::str2Int(masterBaseStr);



		// close the file after writing
		file.close();

		// add the file to the component's file sets
		addHeaderFile(comp, headerOpt->fileInfo_);

		// a header file was added
		changed = true;
	}

	if (changed) {
		// save the changes to the file sets
		utility_->getLibraryInterface()->writeModelToFile(comp);
	}
}
